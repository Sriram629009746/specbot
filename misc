import plotly.graph_objects as go
import pandas as pd
import plotly.express as px
import random

# Generate sample data with 100 unique commands
num_commands = 100
commands = [f"cmd_{i}" for i in range(1, num_commands + 1)]
random.shuffle(commands)  # Shuffle to mix command types

data = {
    "command": [random.choice(commands) for _ in range(500)],  # 500 data points
    "start time": sorted(random.sample(range(1, 1000000, 10), 500)),  # Microsecond timestamps
    "end time": [t + random.randint(10, 500) for t in sorted(random.sample(range(1, 1000000, 10), 500))],
    "position": [random.randint(1, 32) for _ in range(500)],  # Positions in the queue
    "status": [random.choice(["success", "fail"]) for _ in range(500)],  # Success or Fail
    "other details": [f"info_{i}" for i in range(500)]  # Example metadata
}

df = pd.DataFrame(data)

# Sort by start time
df = df.sort_values(by="start time").reset_index(drop=True)

# Get a large enough set of unique colors
plotly_colors = px.colors.qualitative.Light24 + px.colors.qualitative.Alphabet + px.colors.qualitative.Dark24
num_plotly_colors = len(plotly_colors)

# If we have more commands than available colors, generate extra colors using a colorscale
if len(df["command"].unique()) > num_plotly_colors:
    extra_colors_needed = len(df["command"].unique()) - num_plotly_colors
    extra_colors = px.colors.sample_colorscale("rainbow", [i / extra_colors_needed for i in range(extra_colors_needed)])
    all_colors = plotly_colors + extra_colors
else:
    all_colors = plotly_colors

# Assign unique colors to commands
cmd_colors = {cmd: all_colors[i % len(all_colors)] for i, cmd in enumerate(df["command"].unique())}

# Create figure
fig = go.Figure()

# Add lines for each command occurrence
for _, row in df.iterrows():
    hover_text = (
        f"Command: {row['command']}<br>"
        f"Start Time: {row['start time']} µs<br>"
        f"End Time: {row['end time']} µs<br>"
        f"Time Taken: {row['end time'] - row['start time']} µs<br>"
        f"Status: {row['status']}<br>"
        f"Details: {row['other details']}"
    )
    
    fig.add_trace(go.Scatter(
        x=[row["start time"], row["end time"]],
        y=[row["position"], row["position"]],
        mode="lines",
        line=dict(width=2, color=cmd_colors[row["command"]]),
        legendgroup=row["command"],
        showlegend=False,  # Avoid duplicate legend entries
        hoverinfo="text",
        text=hover_text
    ))

# Add a single legend entry for each command
for cmd, color in cmd_colors.items():
    fig.add_trace(go.Scatter(
        x=[None],  # Empty trace for legend
        y=[None],
        mode="lines",
        line=dict(width=2, color=color),
        name=cmd,
        legendgroup=cmd
    ))

# Layout
fig.update_layout(
    height=1000,
    title="Command Execution Timeline with Hover Info",
    xaxis_title="Time (µs)",
    yaxis_title="Queue Position",
    xaxis=dict(
        tickmode="auto",
        dtick=1,  # Microsecond resolution
        range=[0,10000]
    ),
    yaxis=dict(
        tickmode="array",
        tickvals=sorted(df["position"].unique()),  # Show all used positions
        showgrid=True,
        zeroline=False,
        fixedrange=True
    ),
    legend=dict(title="Commands", traceorder="normal", bgcolor="rgba(255,255,255,0.8)")
)

# Show plot
fig.show()



### UPDATED
import plotly.graph_objects as go
import pandas as pd
import plotly.express as px
import random
from plotly.subplots import make_subplots

# Generate sample data with 100 unique commands
num_commands = 100
commands = [f"cmd_{i}" for i in range(1, num_commands + 1)]
random.shuffle(commands)  # Shuffle to mix command types

data = {
    "command": [random.choice(commands) for _ in range(500)],  # 500 data points
    "start time": sorted(random.sample(range(1, 1000000, 10), 500)),  # Microsecond timestamps
    "end time": [t + random.randint(10, 500) for t in sorted(random.sample(range(1, 1000000, 10), 500))],
    "position": [random.randint(1, 32) for _ in range(500)],  # Positions in the queue
    "status": [random.choice(["success", "fail"]) for _ in range(500)],  # Success or Fail
    "other details": [f"info_{i}" for i in range(500)]  # Example metadata
}

df = pd.DataFrame(data)

# Sort by start time
df = df.sort_values(by="start time").reset_index(drop=True)

# Get a large enough set of unique colors
plotly_colors = px.colors.qualitative.Light24 + px.colors.qualitative.Alphabet + px.colors.qualitative.Dark24
num_plotly_colors = len(plotly_colors)

# If we have more commands than available colors, generate extra colors using a colorscale
if len(df["command"].unique()) > num_plotly_colors:
    extra_colors_needed = len(df["command"].unique()) - num_plotly_colors
    extra_colors = px.colors.sample_colorscale("rainbow", [i / extra_colors_needed for i in range(extra_colors_needed)])
    all_colors = plotly_colors + extra_colors
else:
    all_colors = plotly_colors

# Assign unique colors to commands
cmd_colors = {cmd: all_colors[i % len(all_colors)] for i, cmd in enumerate(df["command"].unique())}

# Create figure with shared x-axis
fig = make_subplots(
    rows=2, cols=1,
    shared_xaxes=True,  # Ensures zooming/panning is synchronized
    subplot_titles=["Command Execution Timeline", "Number of Commands in Queue"]
)

# First Subplot: Command Execution Timeline
for _, row in df.iterrows():
    hover_text = (
        f"Command: {row['command']}<br>"
        f"Start Time: {row['start time']} µs<br>"
        f"End Time: {row['end time']} µs<br>"
        f"Time Taken: {row['end time'] - row['start time']} µs<br>"
        f"Status: {row['status']}<br>"
        f"Details: {row['other details']}"
    )
    
    fig.add_trace(go.Scatter(
        x=[row["start time"], row["end time"]],
        y=[row["position"], row["position"]],
        mode="lines",
        line=dict(width=2, color=cmd_colors[row["command"]]),
        legendgroup=row["command"],
        showlegend=False,  # Avoid duplicate legend entries
        hoverinfo="text",
        text=hover_text
    ), row=1, col=1)

# Add a single legend entry for each command
for cmd, color in cmd_colors.items():
    fig.add_trace(go.Scatter(
        x=[None],  # Empty trace for legend
        y=[None],
        mode="lines",
        line=dict(width=2, color=color),
        name=cmd,
        legendgroup=cmd
    ), row=1, col=1)

# Compute number of active commands in queue over time
events = []
for _, row in df.iterrows():
    events.append((row["start time"], +1, row["position"]))  # Command starts
    events.append((row["end time"], -1, row["position"]))    # Command ends

# Sort events by time (resolve start before end if same time)
events.sort()

# Track active positions
active_positions = set()
queue_times = []
queue_sizes = []

for time, change, pos in events:
    if change == +1:  # Command starts
        active_positions.add(pos)
    elif change == -1:  # Command ends
        active_positions.discard(pos)
    
    queue_times.append(time)
    queue_sizes.append(len(active_positions))  # Count active positions

# Second Subplot: Number of Commands in Queue
fig.add_trace(go.Scatter(
    x=queue_times,
    y=queue_sizes,
    mode="lines",
    name="Commands in Queue",
    line=dict(color="blue"),
    hoverinfo="x+y"
), row=2, col=1)

# Update layout for shared X-axis
fig.update_layout(
    height=1000,
    title="Command Execution Timeline & Queue Size",
    xaxis_title="Time (µs)",
    xaxis2_title="Time (µs)",  # Time displayed on both x-axes
    yaxis_title="Queue Position",
    yaxis2_title="Commands in Queue",
    xaxis=dict(
        tickmode="auto",
        dtick=1,  # Microsecond resolution
        range=[0, 50000]  # Set fixed X-axis range
    ),
    yaxis=dict(
        tickmode="array",
        tickvals=sorted(df["position"].unique()),  # Show all used positions
        showgrid=True,
        zeroline=False,
        fixedrange=True  # Fixed Y-axis for first subplot
    ),
    yaxis2=dict(
        showgrid=True,
        zeroline=False
    ),
    legend=dict(title="Commands", traceorder="normal", bgcolor="rgba(255,255,255,0.8)")
)

# Show plot
fig.show()
